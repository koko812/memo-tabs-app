# 📘 LEARNED.md - タブ切り替えメモ帳（ステップ１）

## 📘 LEARNED.md - ver 1.4（タブタイトルのインライン編集と状態の再設計）

---

### ✅ 今回やったこと

* タブタイトルを「インライン編集」できるように機能追加

  * `editingTabId` を導入し、編集対象のタブIDを一時的に管理
  * `editingTabId === tab.id` の場合に `<input>` を表示、そうでなければ `<button>`
  * `onDoubleClick` で編集モードに入り、`onBlur` や `Enter` キーで編集確定
* 編集中は `autoFocus` を用いて即座に入力可能なUXを実現
* タイトル変更時は `setTabs()` を使って対象の `tab.title` を更新
* 編集後のタイトルも `tabs` の一部として `localStorage` に保存されるため、リロードしても保持される
* JSX内の三項演算子を用いた条件描画に慣れ始めた

---

### 🧠 学び・気づき

#### 🔹 JSX内の三項演算子の活用

* `condition ? <A /> : <B />` という構文は、JSX内で「UIを出し分ける」ための定番手法
* `if` 文が使えない理由は、`if` が「文（statement）」であり、JSXの `{}` 内には「式（expression）」しか書けないため

#### 🔹 `editingTabId` と `activeTabId` の役割の分離

* 編集中のタブ（=タイトルを書き換え中）とアクティブなタブ（=本文を編集中）は**意味が違う**
* 状態を分けておくことで、UIの責任が明確になり、柔軟に制御できる

#### 🔹 `autoFocus` の役割

* `<input autoFocus />` と書くことで、描画と同時にフォーカス（カーソル）を自動で入れることができる
* `autoFocus={true}` と同義。Boolean属性として簡略記法が可能

#### 🔹 JSXとDOMの対応関係への理解

* `return <div>...</div>` は、JavaScriptにおける `document.createElement()` + `appendChild()` の進化形
* Reactは `React.createElement()` を使って仮想DOMを生成し、変更がある部分だけを差分レンダリングする

#### 🔹 `onChange` の基本と応用

* `onChange` は入力要素の値が変更された時に実行されるイベントハンドラ
* `e.target.value` によって、現在の入力内容を取得できる
* `onChange={(e) => setText(e.target.value)}` はReactにおける「Controlled Component」の基本パターン

#### 🔹 状態更新関数における「関数型引数」の意味

* `setNextTabNumber(n => n + 1)` のように関数を渡すことで、**最新の状態を安全に参照して更新**できる
* 同期的な処理内での複数回更新や、競合の回避に有効

#### 🔹 初期値を明示的に与える必要性

* `setNextTabNumber(n => n + 1)` を使うには、**`n` の初期値が必須**
* 初回だけ `setNextTabNumber(2)` を明示しているのは、`"メモ1"` を最初に手動で生成しているから
* 初期値がないまま `+1` をしようとすると `undefined + 1 = NaN` になりバグの原因に

#### 🔹 `useEffect(..., [])` の意味

* 第二引数 `[]` は「依存配列」
* 何も依存していないことを意味するので、**マウント時（初回レンダリング時）に1回だけ実行される**
* `componentDidMount` 相当の処理をReact関数型で書くための定石パターン

#### 🔹 `nextTabNumber` を明示的に持つ設計意図

* `"メモ${nextTabNumber}"` のように連番でタイトルをつける設計では、削除の影響を受けずに一意なタイトルを維持できる
* `tabs.length + 1` を使う方法もあるが、削除があるとタイトル重複のリスクがあるため、状態で保持する方が安全

---

### 📝 コミットメッセージ案

```
feat: タブタイトルのインライン編集機能を実装
```

* `editingTabId` によって編集モードを制御
* 三項演算子で `<button>` / `<input>` を条件分岐
* 編集内容は `tabs` の一部として保持・保存
* `autoFocus` によりUX向上

</br>
</br>
</br>

## 📘 LEARNED.md - ver 1.3（localStorageによる状態の永続化）

### ✅ 今回やったこと

* Reactの`useEffect`を活用して、`tabs`や`activeTabId`、`nextTabNumber`といった状態をlocalStorageに保存
* アプリの起動時にlocalStorageから以前の状態を復元するロジックを追加
* データが存在しない（初回アクセス時）場合は、`メモ1`を自動的に生成するように初期化処理を実装
* localStorageの更新は、`tabs`, `activeTabId`, `nextTabNumber`のいずれかが変化したときに自動で実行されるように構成
* 再読み込み（F5）やブラウザ再起動後でもメモ状態が保持されることを確認

---

### 🧠 学び・気づき

#### 🔹 `useEffect`の本当の役割が見えてきた

* `useEffect` は「**副作用（＝レンダリング以外の処理）を扱う場所**」であり、
  状態の読み書き・保存などの処理はここで行うのが正しい。
* 特に localStorage のように「**外部とやり取りする処理**」は `useState` ではできず、**描画が終わったあとに実行される `useEffect` に書くのが自然**。
* 初回のみ実行するためには、`useEffect(() => {...}, [])` のように **依存配列を空にする**。

#### 🔹 localStorageの仕組みと制約を深く理解した

* **オリジン（プロトコル + ホスト + ポート）ごとに完全に分離されている**ため、別ポートやサブドメインでは共有されない。
* ブラウザを閉じても消えない一方で、**タブをまたいで状態が共有されている**ため、編集競合の可能性がある。
* `sessionStorage` との違いも実感：sessionStorage はタブごとで独立し、タブを閉じると消える。

#### 🔹 保存と復元のロジックの落とし穴に気づいた

* `localStorage.getItem()` で取得できるのは文字列なので、必ず `JSON.parse()` が必要。
* `getItem()` で得られた文字列が `"[]"` のような\*\*「空配列」でも truthy な値\*\*として判定されるため、初期化処理が実行されず不具合が起きる可能性がある。
* 解決策としては、`Array.isArray(parsed) && parsed.length > 0` のような**具体的な中身チェック**が有効だった。

#### 🔹 JSON.parse の失敗例と具体的なリスクを知った

* `"[]"`（空配列）は truthy なので `if (saved)` のような書き方では**初期化処理が実行されない可能性**がある。
* `"[object Object]"` のような誤った文字列を `JSON.parse()` すると `SyntaxError` が発生する。
* 対策として、`Array.isArray(parsed) && parsed.length > 0` のような**構造と中身のチェック**が有効だった。
* `try...catch` でエラーを安全に処理することで、破損した保存データにも耐性のある設計が可能になる。

#### 🔹 TypeScript による型安全な復元処理の可能性を感じた

* JavaScriptでは、`localStorage.getItem()` の戻り値が `string | null` であることを**見落としやすい**。
* `TypeScript` を使うことで、これがコンパイル時に明示的にチェックされるようになり、**nullチェックや型ガードの書き忘れを防げる**。
* また、`unknown` 型から始めて、`Array.isArray()` や `"id" in tab` などで型を徐々に確定させていく流れがとても強力。
* これにより、アプリの復元処理が「**安心して読める構造化された安全なコード**」へと昇華される。

#### 🔹 `.tsx` にするだけでもアプリは動作するという事実

* `App.js` → `App.tsx` にファイル名を変えるだけで、Reactは TypeScript モードに切り替わる。
* 型を明示的に書かなくても動作は可能で、**型の追加を徐々に進められる設計移行がしやすい**。
* `.tsx` にしておくことで、今後の拡張（`type Tab` の導入や `useState<T>()` の活用）が**非常にやりやすくなる基盤が整う**。
* 将来的に型安全を取り入れた設計へとステップアップしたくなったときの「足がかり」として有効。

---

### 📝 コミットメッセージ案

```
feat: localStorage を用いたタブ状態の永続化機能を実装
```

* `useEffect` を使って状態を保存・復元
* 初期化・保存・再読み込み後の復元に対応
* tabs.length === 0 のときの初期化処理も追加
* localStorage の仕様に応じた復元ロジックを強化

<</br></br>/br>
## 📘 LEARNED.md - ver 1.2（タブ削除機能 & タイトル重複防止）
### ✅ 今回やったこと

* 各タブの横に 🗑 ボタンを設置し、個別に削除できるようにした
* `handleDeleteTab()` 関数を追加し、対象の `tab.id` を除外するように `setTabs()` を更新
* 削除されたタブがアクティブだった場合、先頭の残存タブを自動的に選択するように切り替え処理を追加
* タブのタイトル番号がj重複しないよう、`nextTabNumber` を状態として管理
* `handleAddTab()` で `nextTabNumber` を用いてタイトルを生成し、タブ追加のたびにカウントを進める

---

### 🧠 学び・気づき

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる。

  * 例：`tabs.filter(tab => tab.id !== id)` → 特定のタブIDを除外した一覧を新しく作る（元の配列は壊さない）

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある。

  * 例：削除されたタブがアクティブだったら `newTabs[0]?.id ?? null` を使って代わりを設定

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**。

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

---

#### ⏱ タイムスタンプを使った ID 管理の理解

（※このセクション末尾に「厳密なID生成関数」の補足あり）

* `Date.now()` を使うことで、**1970年1月1日 00:00:00 UTC** からの経過ミリ秒数を `id` として利用できる。

  * 例：`Date.now()` → `1716185203883` のような13桁の数値
  * 数値なのでソート・比較がしやすく、一意性もある程度確保できる（同じミリ秒内で複数回実行すると重複の可能性はある）

* この「1970年基準」の考え方は UNIX で定められたもので、**UNIXエポック**（UNIX Epoch）と呼ばれる。

  * JavaScriptだけでなく、Python、C、Go、Linuxコマンドなど、多くの言語・環境で共有されている基準
  * これにより、**異なる言語やシステム間でも時刻の共有がしやすくなる**

* `Date.now()` のような仕組みは、**Y2K（2000年問題）には影響を受けなかった**。

  * Y2K問題の原因は「西暦の下2桁だけ保存していたこと」による誤解（例："00"が1900年か2000年か分からない）
  * 一方、`Date.now()` は年ではなく「経過ミリ秒」で記録するため、そういった誤認が起きない

* ただし、32bitシステムでは\*\*2038年問題（Y2K38）\*\*がある。

  * UNIXタイム（秒）を 32bit 整数で扱うと、2038年1月19日でオーバーフロー（2147483647秒）
  * モダンな JavaScript（64bit）やブラウザではすでに対応済みなので問題なし

* 今回のように `id` に `Date.now()` を使うと：

  * `id` の重複を避けやすくなる
  * 整数なのでパフォーマンス的にも軽く、シンプルに管理できる
  * 将来的に「作成日時でソート」なども自然に対応できる

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる。

  * 例：`tabs.filter(tab => tab.id !== id)` → 特定のタブIDを除外した一覧を新しく作る（元の配列は壊さない）

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある。

  * 例：削除されたタブがアクティブだったら `newTabs[0]?.id ?? null` を使って代わりを設定

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**。

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

---

#### 🛡️ 厳密に ID を管理するには？

* `Date.now()` は簡易的な一意性が欲しいときには便利だが、**厳密な一意性が絶対に必要な場面ではやや不十分**。
* 特に「同じミリ秒内に複数のIDが生成される可能性」や、「時間を操作された環境での衝突」などの懸念がある。

##### ✅ JavaScript で使える一意な ID 生成手段：

1. **`crypto.randomUUID()`**（推奨・モダン環境）

```js
const id = crypto.randomUUID();
// 例: 'de305d54-75b4-431b-adb2-eb6b9e546014'
```

* 128bitのUUID（バージョン4）を安全な乱数で生成
* 重複の心配ほぼなし、ユースケースに広く対応
* モダンなブラウザやNode.js（v14.17以降）で使用可能

2. **`uuid` ライブラリ（npm）を使う**

```bash
npm install uuid
```

```js
import { v4 as uuidv4 } from 'uuid';
const id = uuidv4();
```

* サーバー/クライアント問わず安定して使える定番手段

##### 💡 使い分けの目安：

| 手法                    | 特徴           | 用途例                 |
| --------------------- | ------------ | ------------------- |
| `Date.now()`          | 軽量・数値・お手軽    | タブID、UI側の一時データなど    |
| `crypto.randomUUID()` | 安全・厳密・衝突しにくい | データベースID、ログ、セッションなど |
| `uuid` ライブラリ          | 多用途・信頼性高い    | 大規模アプリ、APIリソース識別など  |

---

### 📝 コミットメッセージ案

```
feat: タブ削除機能とタイトル重複防止用の通し番号管理を追加
```

* 各タブの横に 🗑 ボタンを設置し、個別に削除できるようにした
* `handleDeleteTab()` 関数を追加し、対象の `tab.id` を除外するように `setTabs()` を更新
* 削除されたタブがアクティブだった場合、先頭の残存タブを自動的に選択するように切り替え処理を追加
* タブのタイトル番号が重複しないよう、`nextTabNumber` を状態として管理
* `handleAddTab()` で `nextTabNumber` を用いてタイトルを生成し、タブ追加のたびにカウントを進める

---
</br></br></br>

## ✅ 今回やったこと(ver1.1)

* `useState` を使ってメモ（タブ）一覧を状態として管理
* 各タブに `id`, `title`, `content` を持たせて構造化
* `activeTabId` を使って現在のタブを跡貫
* `tabs.map()` で全タブをボタンとして描画
* タブのクリックでアクティブなタブを切り替え
* `＋` ボタンで新しいタブを追加し、自動的に選択状態に
* アクティブなタブの本文を `<textarea>` で編集できるようにした
* `handleChangeContent` の実装により、特定のタブだけを更新するロジックを経由

---

## 🧠 学び・気づき

* タブの状態をオブジェクト配列で持つことで、**構造がシンプルに保てる**
* `id` を `Date.now()` で生成すると、**indexより安定して跡貫できる**
* 条件付きで `style` を切り替えることで、選択中のUIが簡単に実現できる
* `map()` による描画と状態管理は React の基本構k造！
* 最小限の構成（`App.js`, `index.js`）でもアプリが動くという安心感！
* `textarea` は React の **Controlled Component** の例：状態が全てを管理する
* React はレンダリングが起きるたびに **Virtual DOM で少ない部分だけ更新するため高速**
* `onChange` は入力のたびに呼ばれるが、軽い理由がわかった

---

## 🛠 次にやりたいこと

* タブ削除（🗑）機能の追加
* データの保存先を localStorage or API に切り替える
* Markdown入力 & プレビューもゆくゆく試してみたい

---

## 📝 コミットメッセージ案

```
feat: タブの追加と切り替え機能を実装（本文編集機能付き）
```

---

## 🗂 フォルダ構成（最小構成）

```txt
src/
├── App.js        ← メインUI
└── index.js      ← エントリーポイント
```


</br>
</br>
</br>
## ver1.0

## ✅ 今回やったこと

* `useState` を使ってメモ（タブ）一覧を状態として管理
* 各タブに `id`, `title`, `content` を持たせて構造化
* `activeTabId` を使って現在のタブを跡貫
* `tabs.map()` で全タブをボタンとして描画
* タブのクリックでアクティブなタブを切り替え
* `＋` ボタンで新しいタブを追加し、自動的に選択状態に

---

## 🧠 学び・気づき

* タブの状態をオブジェクト配列で持つことで、**構造がシンプルに保てる**
* `id` を `Date.now()` で生成すると、**indexより安定して跡貫できる**
* 条件付きで `style` を切り替えることで、選択中のUIが簡単に実現できる
* `map()` による描画と状態管理は React の基本構造！
* 最小限の構成（`App.js`, `index.js`）でもアプリが動くという安心感！

---

## 🛠 次にやりたいこと

* `textarea` を使ってメモの本文を編集できるようにする
* タブ削除（🗑）機能の追加
* データの保存先を localStorage or API に切り替える
* Markdown入力 & プレビューもゆくゆく試してみたい

---

## 📝 コミットメッセージ案

```
feat: タブの追加と切り替え機能を実装
```

---

## 🗂 フォルダ構成（最小構成）

```txt
src/
├── App.js        ← メインUI
└── index.js      ← エントリーポイント
```
