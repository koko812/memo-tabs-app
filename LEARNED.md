# 📘 LEARNED.md - タブ切り替えメモ帳（ステップ１）
## 📘 LEARNED.md - ver 1.3（localStorageによる状態の永続化）

### ✅ 今回やったこと

* Reactの`useEffect`を活用して、`tabs`や`activeTabId`、`nextTabNumber`といった状態をlocalStorageに保存
* アプリの起動時にlocalStorageから以前の状態を復元するロジックを追加
* データが存在しない（初回アクセス時）場合は、`メモ1`を自動的に生成するように初期化処理を実装
* localStorageの更新は、`tabs`, `activeTabId`, `nextTabNumber`のいずれかが変化したときに自動で実行されるように構成
* 再読み込み（F5）やブラウザ再起動後でもメモ状態が保持されることを確認

---

### 🧠 学び・気づき

#### 🔹 `useEffect`の本当の役割が見えてきた

* `useEffect` は「**副作用（＝レンダリング以外の処理）を扱う場所**」であり、
  状態の読み書き・保存などの処理はここで行うのが正しい。
* 特に localStorage のように「**外部とやり取りする処理**」は `useState` ではできず、**描画が終わったあとに実行される `useEffect` に書くのが自然**。
* 初回のみ実行するためには、`useEffect(() => {...}, [])` のように **依存配列を空にする**。

#### 🔹 localStorageの仕組みと制約を深く理解した

* **オリジン（プロトコル + ホスト + ポート）ごとに完全に分離されている**ため、別ポートやサブドメインでは共有されない。
* ブラウザを閉じても消えない一方で、**タブをまたいで状態が共有されている**ため、編集競合の可能性がある。
* `sessionStorage` との違いも実感：sessionStorage はタブごとで独立し、タブを閉じると消える。

#### 🔹 保存と復元のロジックの落とし穴に気づいた

* `localStorage.getItem()` で取得できるのは文字列なので、必ず `JSON.parse()` が必要。
* `getItem()` で得られた文字列が `"[]"` のような\*\*「空配列」でも truthy な値\*\*として判定されるため、初期化処理が実行されず不具合が起きる可能性がある。
* 解決策としては、`Array.isArray(parsed) && parsed.length > 0` のような**具体的な中身チェック**が有効だった。

#### 🔹 JSON.parse の失敗例と具体的なリスクを知った

* `"[]"`（空配列）は truthy なので `if (saved)` のような書き方では**初期化処理が実行されない可能性**がある。
* `"[object Object]"` のような誤った文字列を `JSON.parse()` すると `SyntaxError` が発生する。
* 対策として、`Array.isArray(parsed) && parsed.length > 0` のような**構造と中身のチェック**が有効だった。
* `try...catch` でエラーを安全に処理することで、破損した保存データにも耐性のある設計が可能になる。

#### 🔹 TypeScript による型安全な復元処理の可能性を感じた

* JavaScriptでは、`localStorage.getItem()` の戻り値が `string | null` であることを**見落としやすい**。
* `TypeScript` を使うことで、これがコンパイル時に明示的にチェックされるようになり、**nullチェックや型ガードの書き忘れを防げる**。
* また、`unknown` 型から始めて、`Array.isArray()` や `"id" in tab` などで型を徐々に確定させていく流れがとても強力。
* これにより、アプリの復元処理が「**安心して読める構造化された安全なコード**」へと昇華される。

#### 🔹 `.tsx` にするだけでもアプリは動作するという事実

* `App.js` → `App.tsx` にファイル名を変えるだけで、Reactは TypeScript モードに切り替わる。
* 型を明示的に書かなくても動作は可能で、**型の追加を徐々に進められる設計移行がしやすい**。
* `.tsx` にしておくことで、今後の拡張（`type Tab` の導入や `useState<T>()` の活用）が**非常にやりやすくなる基盤が整う**。
* 将来的に型安全を取り入れた設計へとステップアップしたくなったときの「足がかり」として有効。

---

### 📝 コミットメッセージ案

```
feat: localStorage を用いたタブ状態の永続化機能を実装
```

* `useEffect` を使って状態を保存・復元
* 初期化・保存・再読み込み後の復元に対応
* tabs.length === 0 のときの初期化処理も追加
* localStorage の仕様に応じた復元ロジックを強化

<</br></br>/br>
## 📘 LEARNED.md - ver 1.2（タブ削除機能 & タイトル重複防止）
### ✅ 今回やったこと

* 各タブの横に 🗑 ボタンを設置し、個別に削除できるようにした
* `handleDeleteTab()` 関数を追加し、対象の `tab.id` を除外するように `setTabs()` を更新
* 削除されたタブがアクティブだった場合、先頭の残存タブを自動的に選択するように切り替え処理を追加
* タブのタイトル番号がj重複しないよう、`nextTabNumber` を状態として管理
* `handleAddTab()` で `nextTabNumber` を用いてタイトルを生成し、タブ追加のたびにカウントを進める

---

### 🧠 学び・気づき

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる。

  * 例：`tabs.filter(tab => tab.id !== id)` → 特定のタブIDを除外した一覧を新しく作る（元の配列は壊さない）

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある。

  * 例：削除されたタブがアクティブだったら `newTabs[0]?.id ?? null` を使って代わりを設定

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**。

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

---

#### ⏱ タイムスタンプを使った ID 管理の理解

（※このセクション末尾に「厳密なID生成関数」の補足あり）

* `Date.now()` を使うことで、**1970年1月1日 00:00:00 UTC** からの経過ミリ秒数を `id` として利用できる。

  * 例：`Date.now()` → `1716185203883` のような13桁の数値
  * 数値なのでソート・比較がしやすく、一意性もある程度確保できる（同じミリ秒内で複数回実行すると重複の可能性はある）

* この「1970年基準」の考え方は UNIX で定められたもので、**UNIXエポック**（UNIX Epoch）と呼ばれる。

  * JavaScriptだけでなく、Python、C、Go、Linuxコマンドなど、多くの言語・環境で共有されている基準
  * これにより、**異なる言語やシステム間でも時刻の共有がしやすくなる**

* `Date.now()` のような仕組みは、**Y2K（2000年問題）には影響を受けなかった**。

  * Y2K問題の原因は「西暦の下2桁だけ保存していたこと」による誤解（例："00"が1900年か2000年か分からない）
  * 一方、`Date.now()` は年ではなく「経過ミリ秒」で記録するため、そういった誤認が起きない

* ただし、32bitシステムでは\*\*2038年問題（Y2K38）\*\*がある。

  * UNIXタイム（秒）を 32bit 整数で扱うと、2038年1月19日でオーバーフロー（2147483647秒）
  * モダンな JavaScript（64bit）やブラウザではすでに対応済みなので問題なし

* 今回のように `id` に `Date.now()` を使うと：

  * `id` の重複を避けやすくなる
  * 整数なのでパフォーマンス的にも軽く、シンプルに管理できる
  * 将来的に「作成日時でソート」なども自然に対応できる

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる。

  * 例：`tabs.filter(tab => tab.id !== id)` → 特定のタブIDを除外した一覧を新しく作る（元の配列は壊さない）

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある。

  * 例：削除されたタブがアクティブだったら `newTabs[0]?.id ?? null` を使って代わりを設定

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**。

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

---

#### 🛡️ 厳密に ID を管理するには？

* `Date.now()` は簡易的な一意性が欲しいときには便利だが、**厳密な一意性が絶対に必要な場面ではやや不十分**。
* 特に「同じミリ秒内に複数のIDが生成される可能性」や、「時間を操作された環境での衝突」などの懸念がある。

##### ✅ JavaScript で使える一意な ID 生成手段：

1. **`crypto.randomUUID()`**（推奨・モダン環境）

```js
const id = crypto.randomUUID();
// 例: 'de305d54-75b4-431b-adb2-eb6b9e546014'
```

* 128bitのUUID（バージョン4）を安全な乱数で生成
* 重複の心配ほぼなし、ユースケースに広く対応
* モダンなブラウザやNode.js（v14.17以降）で使用可能

2. **`uuid` ライブラリ（npm）を使う**

```bash
npm install uuid
```

```js
import { v4 as uuidv4 } from 'uuid';
const id = uuidv4();
```

* サーバー/クライアント問わず安定して使える定番手段

##### 💡 使い分けの目安：

| 手法                    | 特徴           | 用途例                 |
| --------------------- | ------------ | ------------------- |
| `Date.now()`          | 軽量・数値・お手軽    | タブID、UI側の一時データなど    |
| `crypto.randomUUID()` | 安全・厳密・衝突しにくい | データベースID、ログ、セッションなど |
| `uuid` ライブラリ          | 多用途・信頼性高い    | 大規模アプリ、APIリソース識別など  |

---

### 📝 コミットメッセージ案

```
feat: タブ削除機能とタイトル重複防止用の通し番号管理を追加
```

* 各タブの横に 🗑 ボタンを設置し、個別に削除できるようにした
* `handleDeleteTab()` 関数を追加し、対象の `tab.id` を除外するように `setTabs()` を更新
* 削除されたタブがアクティブだった場合、先頭の残存タブを自動的に選択するように切り替え処理を追加
* タブのタイトル番号が重複しないよう、`nextTabNumber` を状態として管理
* `handleAddTab()` で `nextTabNumber` を用いてタイトルを生成し、タブ追加のたびにカウントを進める

---
</br></br></br>

## ✅ 今回やったこと(ver1.1)

* `useState` を使ってメモ（タブ）一覧を状態として管理
* 各タブに `id`, `title`, `content` を持たせて構造化
* `activeTabId` を使って現在のタブを跡貫
* `tabs.map()` で全タブをボタンとして描画
* タブのクリックでアクティブなタブを切り替え
* `＋` ボタンで新しいタブを追加し、自動的に選択状態に
* アクティブなタブの本文を `<textarea>` で編集できるようにした
* `handleChangeContent` の実装により、特定のタブだけを更新するロジックを経由

---

## 🧠 学び・気づき

* タブの状態をオブジェクト配列で持つことで、**構造がシンプルに保てる**
* `id` を `Date.now()` で生成すると、**indexより安定して跡貫できる**
* 条件付きで `style` を切り替えることで、選択中のUIが簡単に実現できる
* `map()` による描画と状態管理は React の基本構k造！
* 最小限の構成（`App.js`, `index.js`）でもアプリが動くという安心感！
* `textarea` は React の **Controlled Component** の例：状態が全てを管理する
* React はレンダリングが起きるたびに **Virtual DOM で少ない部分だけ更新するため高速**
* `onChange` は入力のたびに呼ばれるが、軽い理由がわかった

---

## 🛠 次にやりたいこと

* タブ削除（🗑）機能の追加
* データの保存先を localStorage or API に切り替える
* Markdown入力 & プレビューもゆくゆく試してみたい

---

## 📝 コミットメッセージ案

```
feat: タブの追加と切り替え機能を実装（本文編集機能付き）
```

---

## 🗂 フォルダ構成（最小構成）

```txt
src/
├── App.js        ← メインUI
└── index.js      ← エントリーポイント
```


</br>
</br>
</br>
## ver1.0

## ✅ 今回やったこと

* `useState` を使ってメモ（タブ）一覧を状態として管理
* 各タブに `id`, `title`, `content` を持たせて構造化
* `activeTabId` を使って現在のタブを跡貫
* `tabs.map()` で全タブをボタンとして描画
* タブのクリックでアクティブなタブを切り替え
* `＋` ボタンで新しいタブを追加し、自動的に選択状態に

---

## 🧠 学び・気づき

* タブの状態をオブジェクト配列で持つことで、**構造がシンプルに保てる**
* `id` を `Date.now()` で生成すると、**indexより安定して跡貫できる**
* 条件付きで `style` を切り替えることで、選択中のUIが簡単に実現できる
* `map()` による描画と状態管理は React の基本構造！
* 最小限の構成（`App.js`, `index.js`）でもアプリが動くという安心感！

---

## 🛠 次にやりたいこと

* `textarea` を使ってメモの本文を編集できるようにする
* タブ削除（🗑）機能の追加
* データの保存先を localStorage or API に切り替える
* Markdown入力 & プレビューもゆくゆく試してみたい

---

## 📝 コミットメッセージ案

```
feat: タブの追加と切り替え機能を実装
```

---

## 🗂 フォルダ構成（最小構成）

```txt
src/
├── App.js        ← メインUI
└── index.js      ← エントリーポイント
```
