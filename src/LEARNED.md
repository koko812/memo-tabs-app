# 📘 LEARNED.md - タブ切り替えメモ帳（ステップ１）

## 📘 LEARNED.md - ver 1.2（タブ削除機能 & タイトル重複防止）
### ✅ 今回やったこと
## 📘 LEARNED.md - ver 1.2（タブ削除機能 & タイトル重複防止）

### ✅ 今回やったこと

* 各タブの横に 🗑 ボタンを設置し、個別に削除できるようにした
* `handleDeleteTab()` 関数を追加し、対象の `tab.id` を除外するように `setTabs()` を更新
* 削除されたタブがアクティブだった場合、先頭の残存タブを自動的に選択するように切り替え処理を追加
* タブのタイトル番号がj重複しないよう、`nextTabNumber` を状態として管理
* `handleAddTab()` で `nextTabNumber` を用いてタイトルを生成し、タブ追加のたびにカウントを進める

---

### 🧠 学び・気づき

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる。

  * 例：`tabs.filter(tab => tab.id !== id)` → 特定のタブIDを除外した一覧を新しく作る（元の配列は壊さない）

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある。

  * 例：削除されたタブがアクティブだったら `newTabs[0]?.id ?? null` を使って代わりを設定

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**。

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

---

#### ⏱ タイムスタンプを使った ID 管理の理解

（※このセクション末尾に「厳密なID生成関数」の補足あり）

* `Date.now()` を使うことで、**1970年1月1日 00:00:00 UTC** からの経過ミリ秒数を `id` として利用できる。

  * 例：`Date.now()` → `1716185203883` のような13桁の数値
  * 数値なのでソート・比較がしやすく、一意性もある程度確保できる（同じミリ秒内で複数回実行すると重複の可能性はある）

* この「1970年基準」の考え方は UNIX で定められたもので、**UNIXエポック**（UNIX Epoch）と呼ばれる。

  * JavaScriptだけでなく、Python、C、Go、Linuxコマンドなど、多くの言語・環境で共有されている基準
  * これにより、**異なる言語やシステム間でも時刻の共有がしやすくなる**

* `Date.now()` のような仕組みは、**Y2K（2000年問題）には影響を受けなかった**。

  * Y2K問題の原因は「西暦の下2桁だけ保存していたこと」による誤解（例："00"が1900年か2000年か分からない）
  * 一方、`Date.now()` は年ではなく「経過ミリ秒」で記録するため、そういった誤認が起きない

* ただし、32bitシステムでは\*\*2038年問題（Y2K38）\*\*がある。

  * UNIXタイム（秒）を 32bit 整数で扱うと、2038年1月19日でオーバーフロー（2147483647秒）
  * モダンな JavaScript（64bit）やブラウザではすでに対応済みなので問題なし

* 今回のように `id` に `Date.now()` を使うと：

  * `id` の重複を避けやすくなる
  * 整数なのでパフォーマンス的にも軽く、シンプルに管理できる
  * 将来的に「作成日時でソート」なども自然に対応できる

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる。

  * 例：`tabs.filter(tab => tab.id !== id)` → 特定のタブIDを除外した一覧を新しく作る（元の配列は壊さない）

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある。

  * 例：削除されたタブがアクティブだったら `newTabs[0]?.id ?? null` を使って代わりを設定

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**。

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

---

#### 🛡️ 厳密に ID を管理するには？

* `Date.now()` は簡易的な一意性が欲しいときには便利だが、**厳密な一意性が絶対に必要な場面ではやや不十分**。
* 特に「同じミリ秒内に複数のIDが生成される可能性」や、「時間を操作された環境での衝突」などの懸念がある。

##### ✅ JavaScript で使える一意な ID 生成手段：

1. **`crypto.randomUUID()`**（推奨・モダン環境）

```js
const id = crypto.randomUUID();
// 例: 'de305d54-75b4-431b-adb2-eb6b9e546014'
```

* 128bitのUUID（バージョン4）を安全な乱数で生成
* 重複の心配ほぼなし、ユースケースに広く対応
* モダンなブラウザやNode.js（v14.17以降）で使用可能

2. **`uuid` ライブラリ（npm）を使う**

```bash
npm install uuid
```

```js
import { v4 as uuidv4 } from 'uuid';
const id = uuidv4();
```

* サーバー/クライアント問わず安定して使える定番手段

##### 💡 使い分けの目安：

| 手法                    | 特徴           | 用途例                 |
| --------------------- | ------------ | ------------------- |
| `Date.now()`          | 軽量・数値・お手軽    | タブID、UI側の一時データなど    |
| `crypto.randomUUID()` | 安全・厳密・衝突しにくい | データベースID、ログ、セッションなど |
| `uuid` ライブラリ          | 多用途・信頼性高い    | 大規模アプリ、APIリソース識別など  |

---

### 📝 コミットメッセージ案

```
feat: タブ削除機能とタイトル重複防止用の通し番号管理を追加
```

* 各タブの横に 🗑 ボタンを設置し、個別に削除できるようにした
* `handleDeleteTab()` 関数を追加し、対象の `tab.id` を除外するように `setTabs()` を更新
* 削除されたタブがアクティブだった場合、先頭の残存タブを自動的に選択するように切り替え処理を追加
* タブのタイトル番号が重複しないよう、`nextTabNumber` を状態として管理
* `handleAddTab()` で `nextTabNumber` を用いてタイトルを生成し、タブ追加のたびにカウントを進める

---

### 🧠 学び・気づき

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる。

  * 例：`tabs.filter(tab => tab.id !== id)` → 特定のタブIDを除外した一覧を新しく作る（元の配列は壊さない）

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある。

  * 例：削除されたタブがアクティブだったら `newTabs[0]?.id ?? null` を使って代わりを設定

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**。

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

* `Array.prototype.filter()` を使って「ある要素を除外した新しい配列」を作れる

* 状態が依存する場合（例：アクティブタブIDが削除されたとき）は、それに合わせて **フォールバック処理** を入れる必要がある

* `tabs.length + 1` ではなく `nextTabNumber` のように **通し番号を別で管理する方が安全**

* 状態を分けて管理すると、ロジックが明確で保守しやすくなる（表示用 `title` と内部 `id` は独立しておくと便利）

---

### 📝 コミットメッセージ案

```
feat: タブ削除機能とタイトル重複防止用の通し番号管理を追加
```


## ✅ 今回やったこと(ver1.1)

* `useState` を使ってメモ（タブ）一覧を状態として管理
* 各タブに `id`, `title`, `content` を持たせて構造化
* `activeTabId` を使って現在のタブを跡貫
* `tabs.map()` で全タブをボタンとして描画
* タブのクリックでアクティブなタブを切り替え
* `＋` ボタンで新しいタブを追加し、自動的に選択状態に
* アクティブなタブの本文を `<textarea>` で編集できるようにした
* `handleChangeContent` の実装により、特定のタブだけを更新するロジックを経由

---

## 🧠 学び・気づき

* タブの状態をオブジェクト配列で持つことで、**構造がシンプルに保てる**
* `id` を `Date.now()` で生成すると、**indexより安定して跡貫できる**
* 条件付きで `style` を切り替えることで、選択中のUIが簡単に実現できる
* `map()` による描画と状態管理は React の基本構k造！
* 最小限の構成（`App.js`, `index.js`）でもアプリが動くという安心感！
* `textarea` は React の **Controlled Component** の例：状態が全てを管理する
* React はレンダリングが起きるたびに **Virtual DOM で少ない部分だけ更新するため高速**
* `onChange` は入力のたびに呼ばれるが、軽い理由がわかった

---

## 🛠 次にやりたいこと

* タブ削除（🗑）機能の追加
* データの保存先を localStorage or API に切り替える
* Markdown入力 & プレビューもゆくゆく試してみたい

---

## 📝 コミットメッセージ案

```
feat: タブの追加と切り替え機能を実装（本文編集機能付き）
```

---

## 🗂 フォルダ構成（最小構成）

```txt
src/
├── App.js        ← メインUI
└── index.js      ← エントリーポイント
```


</br>
</br>
</br>
## ver1.0

## ✅ 今回やったこと

* `useState` を使ってメモ（タブ）一覧を状態として管理
* 各タブに `id`, `title`, `content` を持たせて構造化
* `activeTabId` を使って現在のタブを跡貫
* `tabs.map()` で全タブをボタンとして描画
* タブのクリックでアクティブなタブを切り替え
* `＋` ボタンで新しいタブを追加し、自動的に選択状態に

---

## 🧠 学び・気づき

* タブの状態をオブジェクト配列で持つことで、**構造がシンプルに保てる**
* `id` を `Date.now()` で生成すると、**indexより安定して跡貫できる**
* 条件付きで `style` を切り替えることで、選択中のUIが簡単に実現できる
* `map()` による描画と状態管理は React の基本構造！
* 最小限の構成（`App.js`, `index.js`）でもアプリが動くという安心感！

---

## 🛠 次にやりたいこと

* `textarea` を使ってメモの本文を編集できるようにする
* タブ削除（🗑）機能の追加
* データの保存先を localStorage or API に切り替える
* Markdown入力 & プレビューもゆくゆく試してみたい

---

## 📝 コミットメッセージ案

```
feat: タブの追加と切り替え機能を実装
```

---

## 🗂 フォルダ構成（最小構成）

```txt
src/
├── App.js        ← メインUI
└── index.js      ← エントリーポイント
```
